08000000  // ADDI R0, R0, 0   (R[0] = R[0] + 0)
08400001  // ADDI R1, R0, 1   (R[1] = R[0] + 1)
08800002  // ADDI R2, R0, 2   (R[2] = R[0] + 2)
08C00003  // ADDI R3, R0, 3   (R[3] = R[0] + 3)
09000004  // ADDI R4, R0, 4   (R[4] = R[0] + 4)
09400005  // ADDI R5, R0, 5   (R[5] = R[0] + 5)
09800006  // ADDI R6, R0, 6   (R[6] = R[0] + 6)
09C00007  // ADDI R7, R0, 7   (R[7] = R[0] + 7)
0A000008  // ADDI R8, R0, 8   (R[8] = R[0] + 8)
0A400009  // ADDI R9, R0, 9   (R[9] = R[0] + 9)
0A80000A  // ADDI R10, R0, 10  (R[10] = R[0] + 10)
0AC0000B  // ADDI R11, R0, 11  (R[11] = R[0] + 11)
0B00000C  // ADDI R12, R0, 12  (R[12] = R[0] + 12)
0B40000D  // ADDI R13, R0, 13  (R[13] = R[0] + 13)
0B80000E  // ADDI R14, R0, 14  (R[14] = R[0] + 14)
0BC0000F  // ADDI R15, R0, 15  (R[15] = R[0] + 15)
0C000010  // ADDI R16, R0, 16  (R[16] = R[0] + 16)
0C400011  // ADDI R17, R0, 17  (R[17] = R[0] + 17)
0C800012  // ADDI R18, R0, 18  (R[18] = R[0] + 18)
0CC00013  // ADDI R19, R0, 19  (R[19] = R[0] + 19)
0D000014  // ADDI R20, R0, 20  (R[20] = R[0] + 20)
0D400015  // ADDI R21, R0, 21  (R[21] = R[0] + 21)
0D800016  // ADDI R22, R0, 22  (R[22] = R[0] + 22)
0DC00017  // ADDI R23, R0, 23  (R[23] = R[0] + 23)
0E000018  // ADDI R24, R0, 24  (R[24] = R[0] + 24)
0E400019  // ADDI R25, R0, 25  (R[25] = R[0] + 25)
0E80001A  // ADDI R26, R0, 26  (R[26] = R[0] + 26)
0EC0001B  // ADDI R27, R0, 27  (R[27] = R[0] + 27)
0F00001C  // ADDI R28, R0, 28  (R[28] = R[0] + 28)
0F40001D  // ADDI R29, R0, 29  (R[29] = R[0] + 29)
0F80001E  // ADDI R30, R0, 30  (R[30] = R[0] + 30)
0FC0001F  // ADDI R31, R0, 31  (R[31] = R[0] + 31)

// Initialize Fin, Test Start
// 1. ADD R5, R1, R2  (R5 = R[1](1) + R[2](2) = 3). R1, R2는 초기화된 값.
00A12000  // 워드 주소 0x20 (바이트 주소 0x80)

// 2. SUB R6, R4, R1  (R6 = R[4](4) - R[1](1) = 3). R4, R1은 초기화된 값.
04C41000  // 워드 주소 0x21 (바이트 주소 0x84)

// 3. NEG R7, R2      (R7 = -R[2](-2)). R2는 초기화된 값.
06E02000  // 워드 주소 0x22 (바이트 주소 0x88)

// 4. NOT R8, R0      (R8 = ~R[0](~0) = 0xFFFFFFFF). R0은 초기화된 값.
09000000  // 워드 주소 0x23 (바이트 주소 0x8C)

// 5. AND R9, R3, R5  (R3=3, R5는 이전 ADD 결과(3). R9 = 3 & 3 = 3).
//    ADD 명령어는 4단계 전에 실행되어 WB를 지났거나 WB에 있으므로 R5 값은 포워딩/RF를 통해 사용 가능.
0B235000  // 워드 주소 0x24 (바이트 주소 0x90)

// 6. OR R10, R3, R6  (R3=3, R6는 이전 SUB 결과(3). R10 = 3 | 3 = 3).
//    SUB 명령어는 4단계 전에 실행. R6 값 사용 가능.
0EA36000  // 워드 주소 0x25 (바이트 주소 0x94)

// 7. XOR R11, R5, R6 (R5=3, R6=3. R11 = 3 ^ 3 = 0).
//    R5, R6 값 사용 가능.
13656000  // 워드 주소 0x26 (바이트 주소 0x98)

// 8. LSR R12, R4, #1 (R4=4. R12 = R[4] >> 1 = 2). i=0 (즉시값 shamt 사용)
16440001  // 워드 주소 0x27 (바이트 주소 0x9C)

// 9. ASR R13, R7, #1 (R7=-2. R13 = R[7] >>> 1 = -1). i=0
16E70001  // 워드 주소 0x28 (바이트 주소 0xA0)

// 10. SHL R14, R1, #2 (R1=1. R14 = R[1] << 2 = 4). i=0
19C10002  // 워드 주소 0x29 (바이트 주소 0xA4)

// 11. ST R14, #0x100 (M[0x100] = R14(4)). 절대 주소 모드 (rb=31 가정).
//     R14는 바로 이전 SHL 명령어의 결과. EX/MEM -> EX 또는 EX/MEM -> MEM 포워딩 필요. Stall 없음.
137B0100  // Op(10011)ra(R14=01110)rb(R31=11111)Imm(0x100=0000100000000) -> 137F0100 이 정확합니다. (아래 수정)
// 수정된 ST 명령어: (ra는 store할 데이터 레지스터, rb는 주소계산 또는 플래그)
// ST ra(src_data), imm17(addr) -> rb=31
// ST R14, #0x100 -> Opcode: 10011, ra:01110 (R14), rb:11111 (abs), Imm17: 0000100000000 (0x100)
// Binary: 10011 01110 11111 0000100000000
// Hex: 137F0100
137F0100  // 워드 주소 0x2A (바이트 주소 0xA8)

// 12. LD R15, #0x100 (R15 = M[0x100]). ST 명령어의 결과를 확인하기 위함.
//     ST 명령어가 MEM 단계를 지나야 메모리에 반영되므로, 이 LD는 ST 이후 충분한 파이프라인 지연이 필요.
//     ST(MEM) -> LD(IF) 사이에는 2~3 사이클 지연이 자연스럽게 발생 (ST가 MEM 완료하고, LD가 MEM 도달 시).
//     만약 Store-to-Load forwarding이 없다면, ST가 WB를 완료할 때까지 LD는 Stall 필요.
//     여기서는 해저드 없도록 구성하므로, ST의 쓰기가 완료된 후 LD가 읽는다고 가정하거나,
//     이 LD를 나중에 실행하거나, 중간에 다른 명령어들을 더 삽입.
//     간단하게는, 이 LD가 ST의 결과를 바로 다음 사이클에 읽으려 하면 Stall이 필요할 수 있음.
//     포워딩 유닛이 Store-to-Load를 처리하지 않는다면, 이 LD는 몇 개의 NOP 다음에 와야 안전.
//     여기서는 바로 다음에 배치하고, 시뮬레이션 시 Stall 발생 또는 포워딩 동작을 확인하는 용도로 둡니다.
//     (실제 해저드 없는 구성을 위해서는 이 LD 앞에 NOP 2-3개 또는 다른 독립 명령 필요)
//     또는, LD의 목적지를 R14와 다르게 하여 RAW가 없도록 합니다. 여기서는 R15 사용.
13FF0100  // 워드 주소 0x2B (바이트 주소 0xAC)

// --- 테스트 종료를 위한 무한 루프 ---
// 현재 명령어 주소: 0xAC + 4 = 0xB0 (워드 주소 0x2C)
// J (현재 주소 0xB0으로 점프): currentPC = 0xB0+4 = 0xB4. Target = 0xB0. signExt(imm22) = -4.
// imm22 = -4 (0x3FFFFC)
0F03FFFFC // 워드 주소 0x2C (바이트 주소 0xB0) J #-4 (PC 상대)
00000000  // 워드 주소 0x2D (바이트 주소 0xB4) Delay Slot (NOP: ADD R0,R0,R0)